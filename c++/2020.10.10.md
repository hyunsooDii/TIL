## 2020.10.10 TIL

### 알고리즘

##### 두 수의 합

- 숫자들의 배열이 주어지고 표적 숫자가 주어졌다고 합시다.배열에 주어진 숫자들 중 두 개의 숫자를 더하면 표적 숫자가 되는데요, 이때 어떤 두 수를 더하면 표적숫자가 되는지 찾는 문제를 풀어 봅시다.예를 들어서, `[2, 8, 19, 37, 4, 5]` 가 배열로 주어지고 `12` 가 표적으로 주어지면 `8,4` 를 찾아내시면 됩니다.
  - 입력 배열에는 중복되는 수가 없습니다.
  - 입력 배열에는 합해서 표적이 되는 어떤 두 수가 반드시 있습니다.
  - 출력의 순서는 상관 없습니다. 위 예시의 경우, `8,4` 와 `4,8`은 둘 다 정답으로 인정합니다.

``` python
def twoSum(nums, target):
    for n in nums: # 배열 중 첫번째 값을 받아온다.
        if (target - n) in nums: # 배열에서 타겟 - n 값, 즉 n + 배열의 값 = target인 값이 있는지 찾음
            return n, (target-n)

def main():
    print(twoSum([2, 8, 19, 37, 4, 5], 12)) # (4, 8) 혹은 (8, 4)가 리턴되어야 합니다.

if __name__ == "__main__":
    main()
```

##### twoSum 함수

- 먼저 배열의 첫번째 값을 받아온다.
- 배열에서 타겟 -n 값 즉, n+배열의 값 = target인 값이 있는지 찾아 있으면 n과 target-n값을 return

- **하지만** 이 함수는 배열을 2번 돌기 때문에 시간 복잡도에서 비효율적

```python
def twoSum(nums, target):

    nums.sort()  # 오름차순으로 정렬
    i = 0
    j = len(nums) - 1

    while i < j:
        sum = nums[i] + nums[j]
        if sum == target:
            return nums[i], nums[j]
        elif sum > target: # 더 작은 sum을 만들기 위해
            j -= 1
        else: # sum이 타겟보다 작을 때
            i += 1

def main():
    print(twoSum([2, 8, 19, 37, 4, 5], 12))  # (4, 8) 혹은 (8, 4)가 리턴되어야 합니다.

if __name__ == "__main__":
    main()
```

- 내부함수 sort를 이용하여 오름차순 정렬을 통해 효율적으로 배열을 한번 돌게 하여 **시간복잡도 문제 해결**



##### 가장 큰 두 수의 차

- 0보다 큰 정수들의 배열이 주어졌다고 합시다. 여기서 가능한 모든 서로 다른 두 숫자의 차이를 고려 해 보고, 이중 가장 큰 차이를 반환하는 함수를 적어봅시다. 예를 들어서, `[2, 8, 19, 37, 4, 5, 12, 50, 1, 34, 23]` 가 입력으로 주어졌을 경우 가장 큰 차이를 내는 숫자쌍은 `50-1 = 49` 입니다.
  - 두 수의 차에 해당하는 값을 반환하면 됩니다. 위 예시의 경우, 49를 반환합니다.
  - 양의 값을 반환해야 합니다. 위 예시의 경우 -49가 아니라 49를 반환해야 합니다.
  - 배열의 길이는 2보다 크거나 같다고 가정합니다.

```python
def maxTwoDiff(nums):
    nums.sort()
    return nums[-1] - nums[0]
	# nums[-1] = nums[len(nums) -1]

def main():
    print(maxTwoDiff([2, 8, 19, 37, 4, 5, 12, 50, 1, 34, 23])) # 49가 리턴되어야 합니다.

if __name__ == "__main__":
    main()
```

##### maxTwoDiff 함수

- 배열을 오름차순으로 정렬 후 가장 뒷 값과 가장 앞 값의 차이를 구하면 된다.
- 효율적인 코드는 아님

```python
def maxTwoDiff(nums):
    return max(nums) - min(nums)

def main():
    print(maxTwoDiff([2, 8, 19, 37, 4, 5, 12, 50, 1, 34, 23])) # 49가 리턴되어야 합니다.

if __name__ == "__main__":
    main()
```

- **max, min함수**를 이용한다면 굳이 정렬하지 않아도 코드를 효율적으로 작성할 수 있다.



##### 중복된 하나의 숫자 찾아내기

- 숫자들의 배열이 주어집니다. 이 배열은 길이 n을 가지며, 1부터 n-1까지의 숫자로 이루어져있습니다.
  모든 숫자가 배열에 단 한번씩만 나타납니다. 그런데, 딱 하나의 수가 배열에 두번 등장합니다.
  이 중복되는 숫자를 찾아내어 보세요.

  예를 들어서, `[1, 5, 2, 4, 5, 6, 3]` 를 살펴봅시다. 배열의 길이는 7이며, 따라서 1~6까지의 숫자들이 한번씩 등장합니다. 그런데 5만 한번 더 등장했네요.따라서 이 경우에는`5`를 찾아내면 됩니다.

```python

def findDuplicate(nums):
    nums.sort()

    for i in nums:

        if nums[i] == nums[i+1]:
            return nums[i+1]


def main():
    print(findDuplicate([1, 5, 2, 4, 5, 6, 3]))

if __name__ == "__main__":
    main()
```

- 오름차순 정렬 후 전 값과 이후 값을 비교하여 값이 중복되면 return



##### 1로 만들기

- 어떤 수가 입력으로 들어오면 몇번의 연산을 통해 숫자를 1로 가장 빨리 만들 수 있을지 계산하는 함수를 작성해 봅시다.

  할 수 있는 연산은 다음과 같으며 어느연산을 먼저 수행하는지에 대한 순서는 없습니다.

  - 3의 배수라면 3으로 나눕니다.
  - 2의 배수라면 2로 나눕니다.
  - 1을 뺍니다.

  예를 들어 10이 입력되었다면, `10 -> 5 -> 4 -> 2 -> 1`의 4번의 과정을 거쳐 1로 만들 수 있습니다.

  하지만 `10 -> 9 -> 3 -> 1`의 방법으로 3번의 과정을 거쳐 더 빠르게 1로 만들 수 있습니다.

  또한 이것이 가장 빠른 방법입니다.

  이와같이 숫자가 입력되면 가장 빠르게 1로 만드는 연산의 횟수를 출력하는 프로그램을 작성해 봅시다.

```python

def convertTo1(num):
    cnt = 0
    while(1):
        if num == 1:
            break
        if num%3 == 0:
            num /= 3
        elif num%2 == 0:
            num /= 2
        else:
            num -= 1
        cnt += 1
    return cnt


def main():
    print(convertTo1(10))

if __name__ == "__main__":
    main()
```

- **작은 수를 만드는 우선순위**를 두어 계산하면 횟수를 줄이는 프로그램을 작성할 수 있다





